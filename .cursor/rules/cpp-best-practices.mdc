---
description: Core C++ principles and modern best practices
globs: ["**/*.cpp", "**/*.hpp", "**/*.h"]
alwaysApply: true
---

# Modern C++ Best Practices and Core Principles

Follow these core principles when writing C++ code for the Axon project.

## Core Language Principles

### Zero-Overhead Principle
**"You don't pay for what you don't use"** - Abstraction mechanisms should be as efficient as hand-coded, lower-level constructs.

```cpp
// GOOD: std::vector grows dynamically, no overhead if you don't use it
std::vector<int> vec;  // Zero cost if empty

// GOOD: Templates have zero runtime overhead
template<typename T>
constexpr T max(T a, T b) { return (a > b) ? a : b; }  // Compile-time evaluation possible
```

### Express Ideas Directly
Code should express the programmer's intent clearly and directly.

```cpp
// BAD: Unclear intent
auto result = (x > 0) ? x * 2 : 0;

// GOOD: Intent is clear
const bool is_positive = (x > 0);
const int doubled_value = is_positive ? x * 2 : 0;
```

### Prioritize Compile-Time Checking
Catch errors at compile time rather than runtime.

```cpp
// BAD: Runtime check
void process(int* ptr) {
  if (ptr == nullptr) {
    // handle error
  }
}

// GOOD: Compile-time safety with references
void process(int& value) {
  // Guaranteed non-null at compile time
}

// GOOD: Use constexpr for compile-time constants
constexpr int MAX_SIZE = 1024;
constexpr int compute_size() { return MAX_SIZE * 2; }  // Evaluated at compile time
```

### Resource Management (RAII)
Resources are tied to object lifetimes and automatically released when objects go out of scope.

```cpp
// BAD: Manual resource management
void process_file(const std::string& path) {
  FILE* f = fopen(path.c_str(), "r");
  // ... what if exception is thrown?
  fclose(f);  // May not be called
}

// GOOD: RAII with smart pointers or standard library
void process_file(const std::string& path) {
  std::ifstream file(path);  // Automatically closed when file goes out of scope
  if (!file.is_open()) {
    throw std::runtime_error("Cannot open file");
  }
  // File automatically closed, even if exception is thrown
}
```

## Modern C++ Best Practices

### Use Standard Library Components
Prefer standard library containers and algorithms over raw C-style constructs.

```cpp
// BAD: Raw arrays and manual loops
int arr[10];
for (int i = 0; i < 10; ++i) {
  arr[i] = i * 2;
}

// GOOD: Standard library containers
std::vector<int> vec(10);
std::generate(vec.begin(), vec.end(), [n = 0]() mutable { return n++ * 2; });

// GOOD: Range-based for loops
for (const auto& item : vec) {
  process(item);
}
```

### Smart Pointers for Memory Management
Use `std::unique_ptr`, `std::shared_ptr`, and `std::weak_ptr` instead of raw pointers.

```cpp
// BAD: Raw pointer, manual deletion
MyClass* obj = new MyClass();
// ... what if exception is thrown?
delete obj;  // May not be called

// GOOD: Unique pointer (exclusive ownership)
std::unique_ptr<MyClass> obj = std::make_unique<MyClass>();
// Automatically deleted when obj goes out of scope

// GOOD: Shared pointer (shared ownership)
std::shared_ptr<MyClass> obj = std::make_shared<MyClass>();
auto obj2 = obj;  // Both share ownership, deleted when last reference is gone

// GOOD: Weak pointer (non-owning reference, breaks cycles)
std::weak_ptr<MyClass> observer = obj;
```

### Rule of Zero/Three/Five
If your class doesn't manage resources, don't define special member functions (Rule of Zero). If it does, define all five (Rule of Five).

```cpp
// GOOD: Rule of Zero - no resource management, use defaults
class SimpleData {
public:
  int value;
  std::string name;
  // Compiler-generated default constructor, copy, move, destructor are sufficient
};

// GOOD: Rule of Five - manages resources, define all five
class ResourceManager {
public:
  ResourceManager() : resource_(acquire_resource()) {}
  
  ~ResourceManager() { release_resource(resource_); }
  
  // Copy constructor
  ResourceManager(const ResourceManager& other) 
    : resource_(copy_resource(other.resource_)) {}
  
  // Copy assignment
  ResourceManager& operator=(const ResourceManager& other) {
    if (this != &other) {
      release_resource(resource_);
      resource_ = copy_resource(other.resource_);
    }
    return *this;
  }
  
  // Move constructor
  ResourceManager(ResourceManager&& other) noexcept 
    : resource_(other.resource_) {
    other.resource_ = nullptr;
  }
  
  // Move assignment
  ResourceManager& operator=(ResourceManager&& other) noexcept {
    if (this != &other) {
      release_resource(resource_);
      resource_ = other.resource_;
      other.resource_ = nullptr;
    }
    return *this;
  }

private:
  Resource* resource_;
};

// BETTER: Rule of Zero - use smart pointers, let them handle resource management
class ModernResourceManager {
public:
  ModernResourceManager() : resource_(std::make_unique<Resource>()) {}
  // All special member functions use defaults - smart pointer handles cleanup

private:
  std::unique_ptr<Resource> resource_;
};
```

### Expressive Modern Syntax
Use modern C++ features for cleaner, more readable code.

```cpp
// GOOD: Use auto for type deduction (when type is obvious)
auto value = compute_result();  // Type is clear from context
std::vector<int> vec = {1, 2, 3};

// GOOD: Range-based for loops
for (const auto& item : container) {
  process(item);
}

// GOOD: Lambda expressions for small functions
std::for_each(vec.begin(), vec.end(), [](int& x) { x *= 2; });

// GOOD: Structured bindings (C++17)
std::map<std::string, int> scores;
for (const auto& [name, score] : scores) {
  std::cout << name << ": " << score << std::endl;
}

// GOOD: constexpr for compile-time evaluation
constexpr int factorial(int n) {
  return (n <= 1) ? 1 : n * factorial(n - 1);
}
constexpr int fact_5 = factorial(5);  // Evaluated at compile time
```

### Avoid C-style Constructs
Minimize macros, raw pointers, C-style casts, and other legacy C constructs.

```cpp
// BAD: Macros
#define MAX(a, b) ((a) > (b) ? (a) : (b))

// GOOD: Inline function or template
template<typename T>
constexpr const T& max(const T& a, const T& b) {
  return (a > b) ? a : b;
}

// BAD: C-style cast
int* ptr = (int*)malloc(sizeof(int) * 10);

// GOOD: Modern allocation and static_cast if needed
auto ptr = std::make_unique<int[]>(10);  // Preferred
// Or if you must use raw pointer:
int* ptr = static_cast<int*>(std::malloc(sizeof(int) * 10));  // Explicit cast

// BAD: Raw pointer parameters
void process(MyClass* obj);

// GOOD: Reference or smart pointer
void process(MyClass& obj);  // Non-nullable
void process(std::shared_ptr<MyClass> obj);  // Shared ownership
void process(const std::unique_ptr<MyClass>& obj);  // Observing, not taking ownership
```

## Object-Oriented Programming Principles

### Encapsulation
Bundle data and methods together, hide implementation details.

```cpp
// BAD: Public data members, no encapsulation
class Point {
public:
  double x;  // Can be modified anywhere
  double y;
};

// GOOD: Encapsulation with private members and accessors
class Point {
public:
  Point(double x, double y) : x_(x), y_(y) {}
  
  double x() const { return x_; }
  double y() const { return y_; }
  
  void set_x(double x) { x_ = x; }
  void set_y(double y) { y_ = y; }

private:
  double x_;
  double y_;
};
```

### Inheritance and Polymorphism
Use inheritance for "is-a" relationships, prefer composition for "has-a" relationships.

```cpp
// GOOD: Inheritance for is-a relationship
class Animal {
public:
  virtual ~Animal() = default;
  virtual void make_sound() const = 0;  // Pure virtual - abstract class
};

class Dog : public Animal {
public:
  void make_sound() const override { std::cout << "Woof!" << std::endl; }
};

// GOOD: Use composition for has-a relationship
class Engine {
public:
  void start() { /* ... */ }
};

class Car {
public:
  void start() { engine_.start(); }

private:
  Engine engine_;  // Composition, not inheritance
};
```

### Use Override and Final
Always use `override` for virtual function overrides, use `final` when inheritance should stop.

```cpp
// GOOD: Explicit override
class Base {
public:
  virtual void do_work() = 0;
  virtual ~Base() = default;
};

class Derived : public Base {
public:
  void do_work() override {  // Compiler error if signature doesn't match
    // implementation
  }
};

// GOOD: Use final to prevent further inheritance
class LeafClass final : public Base {
public:
  void do_work() override final {  // Cannot be overridden further
    // implementation
  }
};
```

## Additional Best Practices

### Prefer const and constexpr
Make values and functions const whenever possible.

```cpp
// GOOD: const correctness
class Calculator {
public:
  int compute() const {  // Doesn't modify object state
    return cached_value_;  // Can read from const object
  }
  
  void set_value(int v) {  // Modifies object state
    value_ = v;
    cached_value_ = compute_derived();  // Can modify from non-const
  }

private:
  int value_;
  mutable int cached_value_;  // mutable allows modification in const methods
};

// GOOD: constexpr for compile-time constants
constexpr double PI = 3.14159265359;
constexpr int BUFFER_SIZE = 1024;
```

### Use noexcept When Appropriate
Mark functions that don't throw exceptions.

```cpp
// GOOD: noexcept for functions that guarantee no exceptions
void swap(MyClass& a, MyClass& b) noexcept {
  std::swap(a.data_, b.data_);  // std::swap is noexcept for built-in types
}

// GOOD: Move constructors should be noexcept
MyClass(MyClass&& other) noexcept 
  : data_(std::exchange(other.data_, nullptr)) {}
```

### Prefer Pass-by-const-reference for Large Objects
Avoid unnecessary copies.

```cpp
// BAD: Pass by value (expensive copy)
void process_string(std::string s);  // Copies entire string

// GOOD: Pass by const reference
void process_string(const std::string& s);  // No copy, just reference

// GOOD: Pass by value for small, copyable types (int, pointer, etc.)
void increment(int value);  // int is small, pass by value is fine
```

## Summary Checklist

When writing C++ code, ensure:
- ✅ Use RAII for resource management
- ✅ Prefer standard library over raw C constructs
- ✅ Use smart pointers instead of raw pointers
- ✅ Follow Rule of Zero/Three/Five
- ✅ Use `const`, `constexpr`, and `override` appropriately
- ✅ Prefer compile-time checks over runtime checks
- ✅ Use modern syntax (auto, range-for, lambdas)
- ✅ Encapsulate data with private members
- ✅ Express intent clearly and directly
- ✅ Avoid macros, C-style casts, and raw memory management
